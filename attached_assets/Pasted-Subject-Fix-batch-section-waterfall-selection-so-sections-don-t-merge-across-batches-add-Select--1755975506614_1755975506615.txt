Subject: Fix batch→section “waterfall” selection so sections don’t merge across batches; add Select All/Clear; align eligibility and attendance

Goal
- Batch-first “waterfall” UX: when a batch is selected, only that batch’s sections are shown and selectable.
- Prevent cross-batch section merging: sections named “A/B/C…” must be scoped to their batch; selecting “A” under Batch 2024-26 must not also select “A” under Batch 2025-27.
- Add Select All and Clear for sections of the currently selected batch.
- Persist targets as batch-scoped, and update eligibility + attendance to respect batch→section scoping.

Implement exactly

1) Canonical data model for targets (replace any legacy “batch::section” strings)
- Event.targets:
  {
    batches: string[],                // e.g., ["MBA 2024-26","MBA 2025-27"]
    sectionsByBatch: Record<string,string[]>, // { "MBA 2024-26": ["A","B"], "MBA 2025-27": [] }
    programs: string[]                // optional
  }
- Rules:
  - sectionsByBatch[batch] = [] means “all sections for that batch”.
  - Only keys present in sectionsByBatch are relevant; no global “sections” array.

2) Backend write normalization (create/edit)
- On POST/PATCH, accept either legacy payload or the new model and normalize to the new model:
  - If payload has targetBatchSections like ["MBA 2024-26::A","MBA 2025-27::C"], transform to:
    batches = unique(["MBA 2024-26","MBA 2025-27"])
    sectionsByBatch = { "MBA 2024-26": ["A"], "MBA 2025-27": ["C"] }
  - If payload has batches + sections (global), transform to sectionsByBatch for each batch.
  - Always store deduped, trimmed arrays, and sort for stable output.
- Replace, do not merge:
  await db.events.update(id, { targets, updatedAt: now() });

3) Backend eligibility helper (single source of truth)
- Replace all previous paths with:
  function isEligible(user, targets) {
    const batches = Array.isArray(targets?.batches) ? targets.batches : [];
    if (batches.length === 0) return false; // explicit targeting required
    if (!batches.includes(user.batch)) return false;
    const map = targets?.sectionsByBatch || {};
    const scoped = map[user.batch];
    // If no entry or empty array for batch => all sections eligible in that batch
    if (scoped === undefined || scoped.length === 0) return true;
    return scoped.includes(user.section);
  }
- Use this in:
  - GET /api/events (user feed): filter for non-admin users
  - GET /api/events/:id (detail): include eligible boolean

4) Attendance roster builder must respect batch-scoped sections
- When building or rebuilding attendance:
  - For each batch in targets.batches:
    - sections = sectionsByBatch[batch]
    - If sections is undefined or empty → enumerate all sections from directory for that specific batch only
    - Else → use exactly those sections for that batch
  - Create/ensure one sheet per (eventId, batch, section), populate records from directory where student.batch === batch and student.section === section.
- This prevents picking “A” from another batch.

5) API read adaptor
- When returning an event:
  - Always return targets as { batches, sectionsByBatch, programs }
  - Provide a computed flat preview for UI badges if needed:
    preview.sections = Object.entries(sectionsByBatch).map(([b, ss]) => ({ batch: b, sections: ss })) // for display only

6) Frontend form UX (waterfall)
- Step A: Batch selection (multi-select).
- Step B: Section selection panel that reacts to the batch currently in focus:
  - The sections list displays ONLY sections for the currently highlighted/edited batch.
  - Persist selections per batch into sectionsByBatch[activeBatch].
  - Provide “Select All” and “Clear” for the active batch’s sections.
  - Visual indicator if a batch has “all sections” (empty array) vs “some sections”.
- Saving:
  - Send full replacement payload:
    {
      targets: {
        batches: [...selectedBatches],
        sectionsByBatch: { [batch]: [...selectedSectionsForThatBatch] | [] },
        programs: [...]
      },
      ...otherFields
    }

7) Edit form initialization
- When loading an existing event:
  - Hydrate batch picker from targets.batches.
  - For the first batch in that list, set it as active in the UI and load its sections from targets.sectionsByBatch[batch] (undefined or [] = all).
  - Switching active batch swaps the section list to that batch’s scope.

8) Select All / Clear behavior
- Select All: sectionsByBatch[activeBatch] = [] to denote “all sections” (preferred compact representation), OR store the full list explicitly if you must; backend treats [] as all.
- Clear: sectionsByBatch[activeBatch] = [] but with a UI toggle labeled “No restriction (all sections)” or allow a distinct “no sections” state if business rules require at least one section; otherwise, keep [] = all.

9) Display and eligibility badges
- Event card/modal:
  - Use eligible flag from the API (preferred).
  - If computing client-side, use the exact helper logic:
    - must match batch first; then either sectionsByBatch[batch] missing/empty → eligible; else must include user.section.
- For “Target Audience” display, render per batch:
  - MBA 2024-26: All sections (if [] or undefined)
  - MBA 2025-27: A, C, D

10) Rebuild attendance on target changes
- On PATCH when targets change:
  - Call backend to rebuild attendance sheets for that event using the updated sectionsByBatch logic (atomic replace).
- After success, invalidate:
  - ['events','adminList'], ['events','userFeed'], ['events',eventId], ['attendance',eventId]

11) Directory normalization (to avoid cross-batch leaks)
- Ensure StudentDirectory entries store:
  - batch = canonical label (e.g., "MBA 2024-26")
  - section = plain code ("A","B",…)
- If any student.section contains “batch::section”, split and migrate once.

12) Guard against legacy merges
- Remove any code that:
  - Stores/reads a global sections array without batch context for eligibility or attendance.
  - Merges sections by name across batches.
- Add a temporary assertion in roster build:
  - If any sheet is created where student.batch !== the sheet.batch, throw with requestId and eventId.

13) QA checklist (must pass)
- Select Batch 2024-26 only:
  - Section panel shows ONLY sections belonging to 2024-26.
  - Selecting “A” affects only 2024-26::A; eligibility/attendance do not include 2025-27::A.
- Multi-batch:
  - Batches: 2024-26 and 2025-27
  - For 2024-26, choose A,B; for 2025-27, choose C only:
    - Eligible: users in (2024-26 A,B) OR (2025-27 C)
    - Attendance sheets/records exist exactly for those three batch-section combos.
- Select All/Clear:
  - Select All on 2024-26 → denotes all sections for 2024-26 only; 2025-27 selections remain unchanged.
  - Clear on 2025-27 → restores “all sections” for 2025-27, not affecting 2024-26.
- Editing and saving preserves per-batch section choices and does not leak across batches.

14) Deliverables to confirm
- Backend:
  - Normalization and storage of { batches, sectionsByBatch, programs }
  - Eligibility helper applied in list and detail
  - Attendance builder that iterates per batch’s own sections
- Frontend:
  - Waterfall UI with per-batch section list, Select All/Clear
  - Correct payload on save; proper hydration on edit
- Screenshots:
  - Section panel showing filtered sections for active batch
  - Event card’s “Target Audience” rendering per batch
  - Attendance dashboard listing the exact batch-section combinations selected

Apply all steps above, then run a quick end-to-end test with two batches that both have a section “A” and confirm selection never crosses batches.

[1](https://batch.com/blog/posts/event-targeting)
[2](https://docs.mulesoft.com/mule-runtime/latest/batch-processing-concept)
[3](https://www.reddit.com/r/microservices/comments/i8o4mp/eventdriven_batch_processing/)
[4](https://community.sap.com/t5/enterprise-resource-planning-q-a/batch-management/qaq-p/2755984)
[5](https://docs.aws.amazon.com/AWSCloudFormation/latest/TemplateReference/aws-properties-events-rule-batchparameters.html)
[6](https://docs.oracle.com/cd/E28280_01/doc.1111/e14308/recon_service.htm)
[7](https://betterprogramming.pub/a-case-for-event-batching-in-amazon-eventbridge-303f5c3eecee)
[8](https://docs.broadsign.com/broadsign-control/latest/batch-campaigns.html)
[9](https://experienceleague.adobe.com/en/docs/target/using/introduction/how-target-works)
[10](https://www.upsolver.com/blog/batch-stream-a-cheat-sheet)