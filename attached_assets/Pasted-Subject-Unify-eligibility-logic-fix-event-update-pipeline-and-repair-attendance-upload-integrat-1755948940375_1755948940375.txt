Subject: Unify eligibility logic, fix event update pipeline, and repair attendance + upload integrations (copy-paste prompt)

Context
- Event edit (targets) intermittently fails or partially applies.
- Eligibility is inconsistent: two competing implementations (“no open-to-all” vs “open-to-all”).
- Users appear eligible when they shouldn’t, or ineligible when they should.
- Attendance sheets sometimes cover only one section or are missing.
- Upload pipeline (student directory and roll uploads) introduces format inconsistencies that break eligibility and attendance sync.

Goals
- Single source of truth for eligibility across the codebase.
- Deterministic replace-on-edit for event targets.
- Attendance sheets always exist, cover all targeted batches/sections, and sync with directory changes.
- Normalize section/batch formats end-to-end.
- Robust upload validations and transactional behavior.

Implement exactly

1) Create a single eligibility helper and remove divergent logic
- Add shared util (server/lib/eligibility.ts):
  export function isEligible(user, targets) {
    const batches = Array.isArray(targets?.batches) ? targets.batches : [];
    const sections = Array.isArray(targets?.sections) ? targets.sections : [];
    const programs = Array.isArray(targets?.programs) ? targets.programs : [];
    if (batches.length === 0) return false; // explicit targeting required
    const batchOK = batches.includes(user.batch);
    const sectionOK = sections.length === 0 || sections.includes(user.section);
    const programOK = programs.length === 0 || programs.includes(user.program);
    return batchOK && sectionOK && programOK;
  }
- Replace all other eligibility computations with this function:
  - server/routes.ts: remove legacy per-route eligibility
  - server/storage.ts: delete/disable any “open to all if no targeting” branches
- IMPORTANT: Decide policy. If “no targeting = open to all” is actually desired, flip the batches.length === 0 check to return true, and keep it consistent everywhere (list and detail). Do not keep one place true and another false.

2) Normalize event target schema and adaptors
- Canonical targets for every event:
  {
    batches: string[],          // e.g., ["MBA 2025-27"]
    sections: string[],         // e.g., ["A","B"] empty => all sections in those batches
    programs: string[],         // optional
    rollEmailAttendees: string[] // rename from rollNumberAttendees (they are emails)
  }
- Migration/adaptor:
  - When reading legacy fields:
    - targetBatches -> targets.batches
    - targetBatchSections ["MBA 2025-27::A"] -> batches+sections:
      - collect unique batches
      - collect unique sections per batch; if mixed batches with different sections, store union in sections and rely on attendance to combine per batch x section
    - targetSections (legacy, often empty) → ignore unless actually populated
    - rollNumberAttendees → rename to rollEmailAttendees; store validated emails only
- Write path (POST/PATCH) must accept the canonical shape above.

3) Make event edit replace arrays atomically and safely
- In POST and PATCH handlers:
  const norm = a => [...new Set((a||[]).map(x => String(x).trim()))].filter(Boolean).sort();
  const targets = {
    batches: norm(req.body?.targets?.batches),
    sections: norm(req.body?.targets?.sections),
    programs: norm(req.body?.targets?.programs),
    rollEmailAttendees: norm(req.body?.targets?.rollEmailAttendees),
  };
  await tx.events.update(id, { targets, updatedAt: now() });
- Read back once and assert equality in non-prod to catch partial saves.

4) Enforce eligibility uniformly on APIs
- GET /api/events (user feed):
  - If admin/staff: return all with computed eligible field.
  - Else: filter with isEligible(user, ev.targets); include eligible flag in payload for UI.
- GET /api/events/:id:
  - Include eligible using same helper. Do not mark “registered” unless RSVP exists.

5) Attendance sheet linkage and full-roster logic
- Exactly one attendance “container” per event (by eventId). Inside it, maintain one sheet per batch-section pair (or a roster that supports multiple pairs).
- On create/edit:
  - Upsert container by eventId (create if missing).
  - For targets:
    - If sections is empty: build sheets/rosters for all sections of each targeted batch.
    - Else: build sheets for each combination of batch x section present.
  - For each sheet:
    - Sync roster from directory using normalized formats (see step 7).
- On delete: transactionally delete attendance sheets/rows, then event. Missing sheets should not throw.

6) Fix the “eligible for everyone” or “eligible for none” regressions
- Remove any code path in storage.ts that returns true when both batch and batch-section targeting are empty, unless product policy explicitly requires “open to all.” If policy requires open-to-all, set the helper to return true when batches is empty and remove contradictory checks elsewhere.

7) Normalize student directory and section formats end-to-end
- Directory records must be:
  { emailL, rollNumberU, batch, section } where:
  - emailL = lowercase email
  - rollNumberU = uppercase roll number
  - batch = canonical label e.g., "MBA 2025-27"
  - section = plain section code e.g., "A" (never “batch::section”)
- Event targeting uses batch[], section[] separately (never “batch::section” in storage).
- Upload parser fixes:
  - If a sheet name or cell contains “MBA 2025-27::A”, split to batch="MBA 2025-27" and section="A".
  - Trim and normalize to the canonical pair before saving.
- Add a one-time migration script:
  - For students with section values like “MBA 2025-27::A”, split and fix.
  - For events with only targetBatchSections[], convert to batches[] + sections[].

8) Upload robustness and transactions
- Student Directory upload:
  - Validate roll numbers and emails; normalize to canonical batch/section.
  - Run batch upsert in a transaction; on failure, rollback.
  - After success, enqueue an async “attendance resync” job for all events touching the changed batches/sections.
- Roll list upload for events:
  - Rename to rollEmailAttendees if using emails; otherwise actually support roll numbers:
    - If receiving roll numbers, resolve to emails through directory; store emails.
  - Clearly log counts: matched, missing, invalid.

9) Auto-sync attendance on directory changes
- After directory upload completes:
  - For each affected batch/section, find events targeting that audience and enqueue syncStudentsToAttendanceSheet for their sheets.
- Add rate limiting and idempotency guards to avoid duplicate rows.

10) Temporary diagnostics (remove after verification)
- Add requestId and logs:
  - ELIGIBILITY_EVAL with user/batch/section/program, targets, eligible, eventId.
  - ATTENDANCE_ROSTER_BUILD with eventId, targetBatches, targetSections, rosterCount.
  - UPLOAD_NORMALIZE with counts of normalized batch/section, conflicts.
- Add a /admin/diagnostics/events/:id endpoint to dump the server-view of targets and computed audience summary for that event.

11) Frontend alignment
- Edit form:
  - Send full replacement arrays for batches/sections/programs and rollEmailAttendees.
- Event cards and modal:
  - Show “Eligible” only when eligible === true from API; remove any local mismatched logic.
  - Do not show “Registered” unless there’s a real RSVP record.
- Attendance UI:
  - Request the event’s full roster (across all targeted sections) and display counts per section; ensure it’s not filtered down to a single section by mistake.
- After PATCH/POST/UPLOAD:
  - Invalidate and refetch: ['events','userFeed'], ['events','adminList'], ['events',eventId], ['attendance',eventId]

12) Acceptance tests to run and share
- Case A: Batch-only
  - Event: batches ['MBA 2025-27'], sections []
  - User in MBA 2025-27 A → eligible true; in MBA 2024-26 A → false
  - Attendance roster includes all sections of MBA 2025-27
- Case B: Batch+sections
  - Event: batches ['MBA 2025-27'], sections ['C','D']
  - Users in C/D → eligible true; A/B/E → false
  - Attendance roster includes only C and D
- Case C: Roll-email attendees
  - Add a user via roll list → eligible true even if batch/section don’t match
- Case D: Edits replace
  - Change sections from ['C','D'] to ['A'] → eligible flips accordingly; roster rebuilt for A only
- Case E: Upload sync
  - Upload directory changes moving a student from C to D → affected event rosters update automatically

Deliverables
- List of files changed (eligibility helper, routes, storage, upload parsers, migrations, attendance sync).
- One ELIGIBILITY_EVAL log for a positive and a negative case with requestId.
- One ATTENDANCE_ROSTER_BUILD log showing correct rosterCount for a multi-section event.
- Screenshot of an event where a non-targeted user no longer sees Eligible, and a targeted user does.

[1](https://www.zoho.com/backstage/event-management-best-practices.html)
[2](https://theeventscalendar.com/blog/event-management-best-practices/)
[3](https://www.eventmobi.com/blog/event-management-best-practices/)
[4](https://weconvene.com/implementing-a-new-event-management-solution-best-practices-and-pitfalls/)
[5](https://www.zuddl.com/blog/best-event-management-software-guide)
[6](https://www.eventsair.com/blog/event-management-best-practices)
[7](https://moldstud.com/articles/p-implementing-event-management-software-best-practices)
[8](https://cloud.google.com/support/docs/peak-events/best-practices)
[9](https://www.scribd.com/document/532682522/Event-Management-System)
[10](https://mya2zevents.com/blog/event-management-best-practices/)