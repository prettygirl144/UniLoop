Subject: “Add Event” opens white screen — crash triage and hard fix

Goal
- Identify and fix the crash when opening the Add Event screen after the batch→section waterfall changes.
- Prevent future white screens by adding guards, error boundaries, and runtime checks.

Do all steps below.

1) Reproduce with console and network traces
- Open DevTools → Console, Network.
- Click “Add Event”.
- Capture:
  - First red error message + stack (copy text).
  - Any 4xx/5xx requests in Network for prefetches or metadata.
- Keep this tab open while applying fixes to verify in real time.

2) Wrap Add Event route with an error boundary (temporary safety net)
- Add a generic boundary around the Add Event page to avoid full-app crash:
  <Route
    path="/admin/events/new"
    element={
      <RouteErrorBoundary>
        <AddEventPage />
      </RouteErrorBoundary>
    }
  />
- RouteErrorBoundary renders a friendly error UI with a “Retry” and logs error + componentStack.

3) Fix most common null/undefined crashes introduced by waterfall targets
- Initialize safe defaults in AddEventPage and form hook:
  const [form, setForm] = useState({
    title: '',
    description: '',
    location: '',
    startsAt: null,
    endsAt: null,
    targets: {
      batches: [],
      sectionsByBatch: {},   // NEVER null
      programs: [],
    },
    meta: { mandatory: false, tags: [] },
  });
- Active batch state:
  const [activeBatch, setActiveBatch] = useState<string | null>(null);
- Derive sections safely:
  const sectionOptions = useMemo(() => {
    if (!activeBatch) return [];
    return directorySectionsByBatch[activeBatch] || []; // directorySectionsByBatch must be {}
  }, [activeBatch, directorySectionsByBatch]);

- Guard reads everywhere:
  - (targets.sectionsByBatch?.[activeBatch] ?? [])
  - Object.keys(targets.sectionsByBatch || {})

4) Schema normalization on save (avoid undefined access)
- Before POST:
  function normArr(a?: string[]) {
    return [...new Set((a || []).map(s => String(s).trim()))].filter(Boolean).sort();
  }
  const payload = {
    ...form,
    targets: {
      batches: normArr(form.targets.batches),
      sectionsByBatch: Object.fromEntries(
        normArr(form.targets.batches).map(b => [b, normArr(form.targets.sectionsByBatch?.[b])])
      ),
      programs: normArr(form.targets.programs),
    },
  };
  // Remove stray keys not in batches
  for (const k of Object.keys(payload.targets.sectionsByBatch)) {
    if (!payload.targets.batches.includes(k)) delete payload.targets.sectionsByBatch[k];
  }

5) Fix API contract mismatches immediately
- Ensure backend expects targets.sectionsByBatch as an object. Add a compatibility layer to also accept legacy payloads but always persist the canonical shape.
- In controller, coerce:
  const sb = req.body?.targets?.sectionsByBatch;
  if (sb == null || typeof sb !== 'object' || Array.isArray(sb)) {
    // Backstop to avoid crash
    req.body.targets.sectionsByBatch = {};
  }

6) Defensive directory metadata loading
- The form likely fetches:
  - GET /api/directory/metadata → { batches: string[], sectionsByBatch: Record<string,string[]> }
- Add loading guards:
  if (isLoading) return <SkeletonAddEvent />;
  if (error) return <ErrorState retry={refetch} message="Couldn’t load directory metadata" />;
- Ensure the metadata shape is always { batches: [], sectionsByBatch: {} } from the server; never null.

7) Prevent uncontrolled→controlled React warnings (can trigger white screen in strict setups)
- All inputs must receive defined values:
  - value={form.title} not undefined
  - checkbox lists use checked={selected.includes(val)} with selected default []
- For date/time pickers, pass null-safe value and onChange.

8) Guard route params and navigation effects
- If the page reads params.id when in “new” route, ensure it skips fetch/edit logic:
  const isEdit = !!params.id;
  if (!isEdit) skip fetching event detail; initialize empty form.

9) Verify attendance-side effects are not firing on “new”
- If a useEffect triggers “rebuild attendance” or “fetch sheets” when eventId is undefined, guard it:
  useEffect(() => {
    if (!isEdit) return; // only for edit mode
    // fetch event + sheets
  }, [isEdit]);

10) Backend validation returns 400 (not 500)
- In POST /api/events, validate payload and reply 400 with message if:
  - targets.batches is empty
  - sectionsByBatch contains keys not present in batches
  - sections arrays contain invalid codes
- Do NOT throw unhandled errors that crash the route; always next(err) or respond with JSON.

11) Service worker/network
- Ensure the Add Event page’s metadata requests aren’t cached stale. Use network-first for /api/directory/metadata and tag lists during rollout.

12) Logging to pinpoint the crash
- Add console.debug in AddEventPage render path:
  console.debug('AddEvent init', { activeBatch, formTargets: form.targets });
- Server logs for POST:
  log.info({ reqId, targetsPreview: { batches: payload.targets.batches, keys: Object.keys(payload.targets.sectionsByBatch) } }, 'EVENT_CREATE_PAYLOAD');

13) Quick test checklist
- Navigate to Add Event: page renders with empty form, batches dropdown populated, sections panel empty until a batch is selected.
- Select Batch 2024-26: sections list shows only that batch’s sections; Select All marks “all sections” for that batch.
- Add another batch: switching batches swaps the section list correctly; selections are stored per batch.
- Save the event: POST succeeds; event detail shows correct targets; no crash.
- Refresh and edit: form hydrates with per-batch selections; save again without crash.

14) If still white screen: capture and fix typical stack traces
- TypeError: Cannot read properties of undefined (reading 'map')
  - Fix: default arrays/objects before map/access.
- Cannot convert undefined or null to object (Object.keys)
  - Fix: Object.keys(obj || {})
- Invalid attempt to spread non-iterable instance
  - Fix: ensure arrays before spreading [...(x || [])]
- Maximum update depth exceeded
  - Fix: ensure useEffect dependencies are correct and guards prevent setState loops.

Deliverables to share after fix
- Console error screenshot before and after.
- Code diff references (component initialization, save normalization, backend coercion).
- Short screen recording showing Add Event page opening, selecting batches/sections, and saving successfully without a white screen.